"use strict";async function t(t){const e=await crypto.subtle.exportKey("raw",t);return btoa(String.fromCharCode(...new Uint8Array(e)))}async function e(t){const e=Uint8Array.from(atob(t),(t=>t.charCodeAt(0)));return await crypto.subtle.importKey("raw",e,{name:"AES-GCM"},!1,["encrypt","decrypt"])}async function r(t,r){const n=await e(r),a=crypto.getRandomValues(new Uint8Array(12)),o=(new TextEncoder).encode(t),c=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},n,o),i=new Uint8Array([...a,...new Uint8Array(c)]);return btoa(String.fromCharCode(...i))}async function n(t,r){const n=await e(r),a=Uint8Array.from(atob(t),(t=>t.charCodeAt(0))),o=a.slice(0,12),c=a.slice(12),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:o},n,c);return(new TextDecoder).decode(i)}async function a(t){const e=Uint8Array.from(atob(t),(t=>t.charCodeAt(0)));return await crypto.subtle.importKey("spki",e,{name:"RSA-OAEP",hash:"SHA-256"},!1,["encrypt"])}async function o(t){const e=Uint8Array.from(atob(t),(t=>t.charCodeAt(0)));return await crypto.subtle.importKey("pkcs8",e,{name:"RSA-OAEP",hash:"SHA-256"},!1,["decrypt"])}async function c(t,e){const r=await a(e),n=await crypto.subtle.encrypt({name:"RSA-OAEP"},r,(new TextEncoder).encode(t));return btoa(String.fromCharCode(...new Uint8Array(n)))}async function i(t,e){const r=await o(e),n=await crypto.subtle.decrypt({name:"RSA-OAEP"},r,Uint8Array.from(atob(t),(t=>t.charCodeAt(0))));return(new TextDecoder).decode(n)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.base64Decode=function(t){return atob(t)},exports.base64Encode=function(t){return btoa(t)},exports.decryptAES=n,exports.decryptAsyncAES=async function(t,e){return await n(t,e)},exports.decryptAsyncRSA=async function(t,e){return await i(t,e)},exports.decryptRSA=i,exports.encryptAES=r,exports.encryptAsyncAES=async function(t,e){return await r(t,e)},exports.encryptAsyncRSA=async function(t,e){return await c(t,e)},exports.encryptRSA=c,exports.exportAESKey=t,exports.generateAESKey=async function(e=256){if(![256,128,192].includes(e))throw new Error("Invalid key size. Must be 128,192 or 256 bits.");return t(await crypto.subtle.generateKey({name:"AES-GCM",length:e},!0,["encrypt","decrypt"]))},exports.generateECDSAKeyPair=async function(){try{const t=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]),e=await crypto.subtle.exportKey("spki",t.publicKey),r=btoa(String.fromCharCode(...new Uint8Array(e))),n=await crypto.subtle.exportKey("pkcs8",t.privateKey);return{publicKey:r,privateKey:btoa(String.fromCharCode(...new Uint8Array(n)))}}catch(t){throw console.error("ECDSA Key Pair Generation Error:",t),new Error(`Failed to generate ECDSA key pair: ${t}`)}},exports.generateHMACKey=async function(t){if(![256,512].includes(t))throw new Error("Invalid key size. Must be 256 or 512 bits.");const e=await crypto.subtle.generateKey({name:"HMAC",hash:{name:256===t?"SHA-256":"SHA-512"}},!0,["sign","verify"]),r=await crypto.subtle.exportKey("raw",e);return btoa(String.fromCharCode(...new Uint8Array(r)))},exports.generateRSAKeyPair=async function(){const t=await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!0,["encrypt","decrypt"]),e=await crypto.subtle.exportKey("spki",t.publicKey),r=btoa(String.fromCharCode(...new Uint8Array(e))),n=await crypto.subtle.exportKey("pkcs8",t.privateKey);return{publicKey:r,privateKey:btoa(String.fromCharCode(...new Uint8Array(n)))}},exports.generateRandomString=function(t){return crypto.getRandomValues(new Uint8Array(t)).join("")},exports.getPublicECDSAKey=async function(t){try{const e=Uint8Array.from(atob(t),(t=>t.charCodeAt(0))),r=await crypto.subtle.importKey("pkcs8",e,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"]),n=await crypto.subtle.exportKey("spki",r);return btoa(String.fromCharCode(...new Uint8Array(n)))}catch(t){throw console.error("Failed to extract public key from private key:",t),new Error(`Failed to extract public key: ${t}`)}},exports.hashSHA256=async function(t){const e=(new TextEncoder).encode(t),r=await crypto.subtle.digest("SHA-256",e);return btoa(String.fromCharCode(...new Uint8Array(r)))},exports.hashSHA512=async function(t){const e=(new TextEncoder).encode(t),r=await crypto.subtle.digest("SHA-512",e);return btoa(String.fromCharCode(...new Uint8Array(r)))},exports.hmacSHA256=async function(t,e){try{const r=Uint8Array.from(atob(e),(t=>t.charCodeAt(0))),n=await crypto.subtle.importKey("raw",r,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),a=await crypto.subtle.sign("HMAC",n,(new TextEncoder).encode(t));return btoa(String.fromCharCode(...new Uint8Array(a)))}catch(t){throw console.error("HMAC-SHA256 Error:",t),new Error(`Failed to generate HMAC-SHA256 signature: ${t}`)}},exports.hmacSHA512=async function(t,r){const n=await e(r),a=await crypto.subtle.sign("HMAC",n,(new TextEncoder).encode(t));return btoa(String.fromCharCode(...new Uint8Array(a)))},exports.importAESKey=e,exports.importRSAPrivateKey=o,exports.importRSAPublicKey=a,exports.signDataECDSA=async function(t,e){try{const r=Uint8Array.from(atob(e),(t=>t.charCodeAt(0))),n=await crypto.subtle.importKey("pkcs8",r,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]),a=await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},n,(new TextEncoder).encode(t));return btoa(String.fromCharCode(...new Uint8Array(a)))}catch(t){throw console.error("Failed to sign data:",t),new Error(`Failed to sign data: ${t}`)}},exports.verifySignatureECDSA=async function(t,e,r){try{const n=Uint8Array.from(atob(r),(t=>t.charCodeAt(0))),a=await crypto.subtle.importKey("spki",n,{name:"ECDSA",namedCurve:"P-256"},!1,["verify"]),o=Uint8Array.from(atob(e),(t=>t.charCodeAt(0)));return await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},a,o,(new TextEncoder).encode(t))}catch(t){throw console.error("Failed to verify signature:",t),new Error(`Failed to verify signature: ${t}`)}};
//# sourceMappingURL=index.js.map
