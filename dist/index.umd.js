!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).WebEncryption={})}(this,(function(e){"use strict";async function t(e){const t=await crypto.subtle.exportKey("raw",e);return btoa(String.fromCharCode(...new Uint8Array(t)))}async function r(e){const t=Uint8Array.from(atob(e),(e=>e.charCodeAt(0)));return await crypto.subtle.importKey("raw",t,{name:"AES-GCM"},!1,["encrypt","decrypt"])}async function n(e,t){const n=await r(t),a=crypto.getRandomValues(new Uint8Array(12)),o=(new TextEncoder).encode(e),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},n,o),c=new Uint8Array([...a,...new Uint8Array(i)]);return btoa(String.fromCharCode(...c))}async function a(e,t){const n=await r(t),a=Uint8Array.from(atob(e),(e=>e.charCodeAt(0))),o=a.slice(0,12),i=a.slice(12),c=await crypto.subtle.decrypt({name:"AES-GCM",iv:o},n,i);return(new TextDecoder).decode(c)}async function o(e){const t=Uint8Array.from(atob(e),(e=>e.charCodeAt(0)));return await crypto.subtle.importKey("spki",t,{name:"RSA-OAEP",hash:"SHA-256"},!1,["encrypt"])}async function i(e){const t=Uint8Array.from(atob(e),(e=>e.charCodeAt(0)));return await crypto.subtle.importKey("pkcs8",t,{name:"RSA-OAEP",hash:"SHA-256"},!1,["decrypt"])}async function c(e,t){const r=await o(t),n=await crypto.subtle.encrypt({name:"RSA-OAEP"},r,(new TextEncoder).encode(e));return btoa(String.fromCharCode(...new Uint8Array(n)))}async function y(e,t){const r=await i(t),n=await crypto.subtle.decrypt({name:"RSA-OAEP"},r,Uint8Array.from(atob(e),(e=>e.charCodeAt(0))));return(new TextDecoder).decode(n)}e.base64Decode=function(e){return atob(e)},e.base64Encode=function(e){return btoa(e)},e.decryptAES=a,e.decryptAsyncAES=async function(e,t){return await a(e,t)},e.decryptAsyncRSA=async function(e,t){return await y(e,t)},e.decryptRSA=y,e.encryptAES=n,e.encryptAsyncAES=async function(e,t){return await n(e,t)},e.encryptAsyncRSA=async function(e,t){return await c(e,t)},e.encryptRSA=c,e.exportAESKey=t,e.generateAESKey=async function(e=256){if(![256,128,192].includes(e))throw new Error("Invalid key size. Must be 128,192 or 256 bits.");return t(await crypto.subtle.generateKey({name:"AES-GCM",length:e},!0,["encrypt","decrypt"]))},e.generateECDSAKeyPair=async function(){try{const e=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]),t=await crypto.subtle.exportKey("spki",e.publicKey),r=btoa(String.fromCharCode(...new Uint8Array(t))),n=await crypto.subtle.exportKey("pkcs8",e.privateKey);return{publicKey:r,privateKey:btoa(String.fromCharCode(...new Uint8Array(n)))}}catch(e){throw console.error("ECDSA Key Pair Generation Error:",e),new Error(`Failed to generate ECDSA key pair: ${e}`)}},e.generateHMACKey=async function(e){if(![256,512].includes(e))throw new Error("Invalid key size. Must be 256 or 512 bits.");const t=await crypto.subtle.generateKey({name:"HMAC",hash:{name:256===e?"SHA-256":"SHA-512"}},!0,["sign","verify"]),r=await crypto.subtle.exportKey("raw",t);return btoa(String.fromCharCode(...new Uint8Array(r)))},e.generateRSAKeyPair=async function(){const e=await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!0,["encrypt","decrypt"]),t=await crypto.subtle.exportKey("spki",e.publicKey),r=btoa(String.fromCharCode(...new Uint8Array(t))),n=await crypto.subtle.exportKey("pkcs8",e.privateKey);return{publicKey:r,privateKey:btoa(String.fromCharCode(...new Uint8Array(n)))}},e.generateRandomString=function(e){return crypto.getRandomValues(new Uint8Array(e)).join("")},e.getPublicECDSAKey=async function(e){try{const t=Uint8Array.from(atob(e),(e=>e.charCodeAt(0))),r=await crypto.subtle.importKey("pkcs8",t,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"]),n=await crypto.subtle.exportKey("spki",r);return btoa(String.fromCharCode(...new Uint8Array(n)))}catch(e){throw console.error("Failed to extract public key from private key:",e),new Error(`Failed to extract public key: ${e}`)}},e.hashSHA256=async function(e){const t=(new TextEncoder).encode(e),r=await crypto.subtle.digest("SHA-256",t);return btoa(String.fromCharCode(...new Uint8Array(r)))},e.hashSHA512=async function(e){const t=(new TextEncoder).encode(e),r=await crypto.subtle.digest("SHA-512",t);return btoa(String.fromCharCode(...new Uint8Array(r)))},e.hmacSHA256=async function(e,t){try{const r=Uint8Array.from(atob(t),(e=>e.charCodeAt(0))),n=await crypto.subtle.importKey("raw",r,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),a=await crypto.subtle.sign("HMAC",n,(new TextEncoder).encode(e));return btoa(String.fromCharCode(...new Uint8Array(a)))}catch(e){throw console.error("HMAC-SHA256 Error:",e),new Error(`Failed to generate HMAC-SHA256 signature: ${e}`)}},e.hmacSHA512=async function(e,t){const n=await r(t),a=await crypto.subtle.sign("HMAC",n,(new TextEncoder).encode(e));return btoa(String.fromCharCode(...new Uint8Array(a)))},e.importAESKey=r,e.importRSAPrivateKey=i,e.importRSAPublicKey=o,e.signDataECDSA=async function(e,t){try{const r=Uint8Array.from(atob(t),(e=>e.charCodeAt(0))),n=await crypto.subtle.importKey("pkcs8",r,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]),a=await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},n,(new TextEncoder).encode(e));return btoa(String.fromCharCode(...new Uint8Array(a)))}catch(e){throw console.error("Failed to sign data:",e),new Error(`Failed to sign data: ${e}`)}},e.verifySignatureECDSA=async function(e,t,r){try{const n=Uint8Array.from(atob(r),(e=>e.charCodeAt(0))),a=await crypto.subtle.importKey("spki",n,{name:"ECDSA",namedCurve:"P-256"},!1,["verify"]),o=Uint8Array.from(atob(t),(e=>e.charCodeAt(0)));return await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},a,o,(new TextEncoder).encode(e))}catch(e){throw console.error("Failed to verify signature:",e),new Error(`Failed to verify signature: ${e}`)}},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
